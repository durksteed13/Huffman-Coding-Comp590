package decoder;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.Collections;

import io.InputStreamBitSource;
import io.InsufficientBitsLeftException;
import io.OutputStreamBitSink;

public class Decoder {
	
	public static void main(String args[]) throws InsufficientBitsLeftException, IOException {
		
		ArrayList<DSymbol> treeLengths = new ArrayList<DSymbol>();
		int numSymbols;
		
		//input source --> to be decoded
		String file = "data/encoded.dat";
		InputStream iStream = new FileInputStream(file);
		InputStreamBitSource iStreamSource = new InputStreamBitSource(iStream);
		
		//used for part 3 questions
		//compressed entropy
		File fileb = new File(file);
		long numBits = 8*(fileb.length() - 260);
		
		//output source
		String outfile = "data/decoded.txt";
		OutputStream oStream = new FileOutputStream(outfile);
		OutputStreamBitSink oStreamSource = new OutputStreamBitSink(oStream);

		//gather lengths of the canonical tree and their corresponding character
		for(int i = 0; i < 256; i++) {
			treeLengths.add(new DSymbol(iStreamSource.next(8), (char)i));
		}
		
		//get total number of characters in the text 
		numSymbols = iStreamSource.next(32);
		
		Collections.sort(treeLengths);
		
		//create canonical tree with given lengths
		CanonicalTree tree = new CanonicalTree(treeLengths);

		//go through rest of decoded document byte-by-byte matching Huffman codes
		//to the codes generated by the canonical tree
		int decoded = 0;
		
		while (decoded < numSymbols) {
			Node current = tree.getRoot();
			while(true) {
				if(current.isLeaf()) {	
					break;
				}
				else {
					int currentbit = iStreamSource.next(1);
					if(currentbit == 0) {
						current = current.left;
					}
					else {
						current = current.right;
					}
				}
			}
			
			//write the character to the output text
			oStreamSource.write((int)current.getChar(), 8);
			decoded++;
		}
		
		//pad remaining bits in decoded document
		oStreamSource.padToWord();	
		
		//compressed entropy
		System.out.println(((double)(numBits))/numSymbols);
		
		System.out.println("done");
	}
}
